using DrWatson
@quickactivate "ElectrochemCO2ReductionGold"
using LiquidElectrolytes, ExtendableGrids, PreallocationTools, LessUnitful
using VoronoiFVM, ForwardDiff

@kwdef mutable struct ElectrolyteData <: AbstractElectrolyteData
    "Number of ionic species."
    nc::Int
	
    "Number of surface species"
    na::Int
	
    "Potential index in species list."
    iœï::Int = nc + na + 1

    "Pressure index in species list"
    ip::Int = nc + na + 2

    "Mobility coefficient"
    D::Vector{Float64} = fill(2.0e-9 * ufac"m^2/s", nc)

    "Charge numbers of ions"
    z::Vector{Int}

    "Molar weight of solvent"
    M0::Float64 = 18.0153 * ufac"g/mol"

    "Molar weight of ions"
    M::Vector{Float64} = fill(M0, nc)

    "Molar volume of solvent"
    v0::Float64 = 1 / (55.4 * ufac"M")

    "Molar volumes of ions"
    v::Vector{Float64} = fill(v0, nc)

    "Solvation numbers"
    Œ∫::Vector{Float64} = fill(0.0, nc)

    "Bulk ion concentrations"
    c_bulk::Vector{Float64} = fill(0.1 * ufac"M", nc)

    "Bulk voltage"
    œï_bulk::Float64 = 0.0 * ufac"V"

    "Bulk pressure"
    p_bulk::Float64 = 1.0e-2

    "Bulk boundary number"
    Œì_bulk::Int = 2

    "Working electrode voltage"
    œï_we::Float64 = 0.0 * ufac"V"

    "Working electrode  boundary number"
    Œì_we::Int = 1

    "Temperature"
    T::Float64 = (273.15 + 25) * ufac"K"

    "Molar gas constant scaled with temperature"
    RT::Float64 = ph"R" * T

    "Faraday constant"
    F::Float64 = ph"N_A*e"

    "Dielectric permittivity of solvent"
    Œµ::Float64 = 78.49

    "Dielectric permittivity of vacuum"
    Œµ_0::Float64 = ph"Œµ_0"

    "Pressure scaling factor"
    pscale::Float64 = 1.0e9

    "Local electroneutrality switch"
    eneutral::Bool = false

    """
    [Flux caculation scheme](@id fluxes)
    This allows to choose between
    - `:Œºex` (default): excess chemical potential (SEDAN) scheme, see [`sflux`](@ref)
    - `:act` : scheme based on reciprocal activity coefficients, see [`aflux`](@ref)
    - `:cent` : central scheme, see [`cflux`](@ref).
    """
    scheme::Symbol = :Œºex

    """
    Regularization parameter used in [`rlog`](@ref)
    """
    epsreg::Float64 = 1.0e-20

    """
    Species weights for norms in solver control.
    """
    weights::Vector{Float64} = [v..., zeros(na)..., 1.0, 1.0]
	
	"Number of reactions in the bulk"
	nr::Int64
	
	"Stoichiometric coefficients for the bulk reactions"
	Œ≥::Matrix{Int64}

	"Stoichiometric coefficents of water for the bulk reactions"
	Œ≥H‚ÇÇO::Vector{Int64}
	
	"Forward rate constants for the bulk reactions"
	kf::Vector{Float64}

	"Backward rate constants for the bulk reactions"
	kb::Vector{Float64}
	
	"relative chemical potential in the standard state"
	Œº¬∞::Vector{Float64}

	"Relative Chemical potential of water in the standard state"
	Œº¬∞H‚ÇÇO::Float64

	"Adsorption rate constants"
	k¬∞‚Çê::Vector{Float64}

	"Symmetry factors for adsorbtion reactions"
	Œ≤‚Çê::Vector{Union{Missing, Float64}} = fill(missing, nc)

	"Kinetic barriers for the adsorbtion reactions"
	‚Ñ¨‚Çê::Vector{Float64} = fill(0.0, nc)
	
	"Number of surface reactions"
	nr‚Çõ::Int64

	"Stoichiometric coefficients in the surface reactions"
	Œ≥‚Çõ::Matrix{Int64}
	
	"Stoichiometric coefficients of water for the surface reactions"
	Œ≥‚ÇõH‚ÇÇO::Vector{Int64}
	
	"relative chemical potential in the standard state on the surface"
	Œº¬∞‚Çõ::Vector{Float64}

	"Surface rate constants"
	k¬∞‚Çõ::Vector{Float64}
	
	"Symmetry factors for surface reactions"
	Œ≤‚Çõ::Vector{Union{Missing, Float64}} = fill(missing, nr‚Çõ)

	"Kinetic barriers for the surface reactions"
	‚Ñ¨‚Çõ::Vector{Float64} = fill(0.0, nr‚Çõ)

	# not yet needed
	# "reference molar density of metal ions in the electrode"
	# cM¬∞::Float64 = 5.86e28 / ph"N_A" * ufac"m"^(-3)
	
	# "molar density of free electrons in the electrode"
	# ce::Float64 = 1 * cM¬∞

	"molar area of the metal ions"
	aM::Float64 = 7.1233e8
	
	cM‚Çõ::Float64 = 1.42e8 * ufac"mol/cm^2"
	
	# "molar chemical potential of the free electrons in the metal electrode"
	# Œºe::Float64 = (3/(8*œÄ))^(2/3) * ph"h"^2 / (2 * ph"m_e") * ph"N_A"^(5/3) * ce^(2/3)
	
	"molar surface chemical potential of the electrons on the metal electrode surface"
	Œºe‚Çõ::Float64 = 4.5071 * ufac"eV" * ph"N_A"

	"number of available surface sites per metal atom"
	œâM::Int = 1
	
	"number of adsorption sites per molecule"
	œâ::Vector{Int64} = fill(1, na)

	"hbond-adsorbate correction constants"
	hbond_consts::Vector{@NamedTuple{a::Float64, b::Float64}}
end

@enum ActivityType pressureconstrained latticeconstrained

const nc = 7
const na = 8

const nr = 5
const nr‚Çõ= 2

begin # enumeration of the involved species
	const iK‚Å∫ 		= 1
	const iH‚Å∫ 		= 2
	const iHCO‚ÇÉ‚Åª 	= 3
	const iCO‚ÇÉ¬≤‚Åª 	= 4
	const iCO‚ÇÇ 		= 5
	const iOH‚Åª 		= 6
	const iCO 		= 7
	const iCOOH 	= 8  # only in adsorbed phase, not bulk phase
end

const pH = 6.8

begin # geometrical parameters
	const hmin 		= 1.0e-6 	* ufac"Œºm"
	const hmax 		= 1.0  		* ufac"Œºm" 
	const nref  	= 0
	const L 		= 60.0 		* ufac"Œºm" 
	const Œì_we 		= 1
	const Œì_bulk 	= 2
end

begin # definition of charge numbers
	const z = zeros(Int64, nc)
	z[iK‚Å∫] = 1
	z[iH‚Å∫] = 1
	z[iHCO‚ÇÉ‚Åª] = -1
	z[iCO‚ÇÉ¬≤‚Åª] = -2
	z[iOH‚Åª] = -1
	z[iCO] = 0
	z[iCO‚ÇÇ] = 0
end

begin # bulk reaction coefficents
	const Œ≥ = zeros(Int64, nr, nc)
	const Œ≥H‚ÇÇO = zeros(Int64, nr)
	# CO‚ÇÇ + OH‚Åª <--> HCO‚ÇÉ‚Åª
	Œ≥[1, iCO‚ÇÇ] = -1
	Œ≥[1, iOH‚Åª] = -1
	Œ≥[1, iHCO‚ÇÉ‚Åª] = 1
	

	# HCO‚ÇÉ‚Åª + OH‚Åª <--> CO‚ÇÉ¬≤‚Åª + H‚ÇÇO
	Œ≥[2, iHCO‚ÇÉ‚Åª] = -1
	Œ≥[2, iOH‚Åª] = -1
	Œ≥[2, iCO‚ÇÉ¬≤‚Åª] = 1
	Œ≥H‚ÇÇO[2] = 1

	# H‚ÇÇO + CO‚ÇÇ <--> HCO‚ÇÉ‚Åª + H‚Å∫
	Œ≥[3, iCO‚ÇÇ] = -1
	Œ≥[3, iH‚Å∫] = 1
	Œ≥[3, iHCO‚ÇÉ‚Åª] = 1
	Œ≥H‚ÇÇO[3] = -1

	# HCO‚ÇÉ‚Åª <--> CO‚ÇÉ¬≤‚Åª + H‚Å∫
	Œ≥[4, iHCO‚ÇÉ‚Åª] = -1
	Œ≥[4, iH‚Å∫] = 1
	Œ≥[4, iCO‚ÇÉ¬≤‚Åª] = 1

	# H‚ÇÇO <--> H‚Å∫ + OH‚Åª
	Œ≥[5, iH‚Å∫] = 1
	Œ≥[5, iOH‚Åª] = 1
	Œ≥H‚ÇÇO[5] = -1
end

begin # bulk rate constants
	const ke = [4.44e7 / (ufac"mol/dm^3"), 4.66e3 / (ufac"mol/dm^3"), 4.44e-7 * (ufac"mol/dm^3"), 4.66e-5 / (ufac"mol/dm^3"), 1.0e-14 * (ufac"mol/dm^3")^2]
	const kf = [5.93e3 / (ufac"mol/ dm^3 / s"), 1.0e8 / (ufac"mol / dm^3 / s"), 3.7e-2 / ufac"s", 59.44e3 / (ufac"mol / dm^3 / s"), 2.4e-5 * (ufac"mol / dm^3 / s")]
	const kb = kf ./ ke
end

begin # bulk diffusion coefficents
	const D = zeros(Float64, nc)
	D[iK‚Å∫] = 9.310e-9
	D[iH‚Å∫] = 1.957e-9
	D[iHCO‚ÇÉ‚Åª] = 1.185e-9
	D[iCO‚ÇÉ¬≤‚Åª] = 0.923e-9
	D[iCO‚ÇÇ] = 1.91e-9
	D[iOH‚Åª] = 5.273e-9
	D[iCO] = 2.23e-9
end

begin # bulk concentrations
	const c_bulk = zeros(Float64, nc)
	c_bulk[iH‚Å∫] = 10^(-pH) * ufac"mol / dm^3"
	c_bulk[iHCO‚ÇÉ‚Åª] = 0.091 * ufac"mol / dm^3"
	c_bulk[iCO‚ÇÉ¬≤‚Åª] = 2.68e-5 * ufac"mol / dm^3"
	c_bulk[iCO‚ÇÇ] = 0.033 * ufac"mol / dm^3"
	c_bulk[iOH‚Åª] = 10^(pH - 14) * ufac"mol / dm^3"
	c_bulk[iCO] = 0.0001 * ufac"mol / dm^3"
	c_bulk[iK‚Å∫] = -sum([c_bulk[i] * z[i] for i in 1:nc if i != iK‚Å∫]) / z[iK‚Å∫] # electroneutrality condition
end

begin # surface reaction coefficents
	const Œ≥‚Çõ = zeros(Int64, nr‚Çõ, na)
	const Œ≥‚ÇõH‚ÇÇO = zeros(Int64, nr‚Çõ)

	# CO2(ads) + H‚ÇÇO(l) + e‚Åª <-> COOH(ads) + OH‚Åª(aq)
	Œ≥‚Çõ[1, iCO‚ÇÇ] = -1
	Œ≥‚Çõ[1, iCOOH] = 1
	Œ≥‚Çõ[1, iOH‚Åª] = 1
	Œ≥‚ÇõH‚ÇÇO[1] = -1

	# COOH(ads) + H‚ÇÇO(l) + e‚Åª <-> CO(ads) + OH‚Åª(aq) + H‚ÇÇO(l)
	Œ≥‚Çõ[2, iCOOH] = -1
	Œ≥‚Çõ[2, iCO] = 1
	Œ≥‚Çõ[2, iOH‚Åª] = 1
	Œ≥‚ÇõH‚ÇÇO[2] = 0 # !?

	# # CO2(ads) + H‚Å∫ + e‚Åª <-> COOH(ads)
	# Œ≥‚Çõ[3, iCO‚ÇÇ] = -1
	# Œ≥‚Çõ[3, iH‚Å∫] = -1
	# Œ≥‚Çõ[3, iCOOH] = 1

	# # COOH(ads) +  H‚Å∫ + e‚Åª <-> CO(ads) + H‚ÇÇO(l)
	# Œ≥‚Çõ[4, iCOOH] = -1
	# Œ≥‚Çõ[4, iH‚Å∫] = -1
	# Œ≥‚Çõ[4, iCO] = 1
	# Œ≥‚ÇõH‚ÇÇO[4] = 1
end

const k¬∞‚Çõ = fill(1.0e13 / ufac"s", nr‚Çõ)

const k¬∞‚Çê = fill(1.0e13 / ufac"s", nc)
k¬∞‚Çê[iCO] = 1.0e8 / ufac"s"

const Œ≤‚Çõ = convert(Vector{Union{Float64, Missing}}, fill(missing, nr‚Çõ))
Œ≤‚Çõ[2] = 0.5

const Œ≤‚Çê = convert(Vector{Union{Float64, Missing}}, fill(missing, nc))

const S = 1.0e-5 / ph"N_A" * (1.0e10)^2 * ufac"mol / m^2"

const hbond_consts = [
	(; a = 0.0, b = 0.0),
	(; a = 0.0, b = 0.0),
	(; a = 0.0, b = 0.0),
	(; a = 0.0, b = 0.0),
	(; a = 0.0297720125 / (ufac"ŒºA/cm^2"), b = -0.000286600929 / (ufac"ŒºA/cm^2")^2),
	(; a = 0.0, b = 0.0),
	(; a = -0.00942574086 / (ufac"ŒºA/cm^2"), b = -0.000189106972 / (ufac"ŒºA/cm^2")^2),
	(; a = 0.00226896383 / (ufac"ŒºA/cm^2"), b = -9.0295682e-05 / (ufac"ŒºA/cm^2")^2),
]

const voltages = (-1.5:0.1:0.0)

function simulate(; Œº¬∞, Œº¬∞‚Çõ, Œº¬∞H‚ÇÇO, Œº¬∞TS, Œ∫, v, activitytype, p_bulk = 0.0, pscale = 1.0e9, hmin = 1.0e-6 * ufac"Œºm", max_round = 1000, maxiters = 100, reltol = 1.0e-10, abstol = 1.0e-10, tol_round = 1.0e-10, tol_mono = 1.0e-10, damp_initial = 0.1, damp_growth = 1.1)

	# grid
	grid =  let
		X = geomspace(0, L, hmin, hmax)
		simplexgrid(X)
	end

	# reaction
	#reaction(f, u, node, data) = reaction(f, u, node, data)

	# celldata
	celldata = let 
		‚Ñ¨‚Çõ = zeros(Float64, nr‚Çõ)
		‚Ñ¨‚Çõ[2] = Œº¬∞TS - Œº¬∞‚Çõ[iCOOH] - Œº¬∞H‚ÇÇO

		‚Ñ¨‚Çê = zeros(Float64, nc)
		
		ElectrolyteData(; nc, na, z, c_bulk, D, Œº¬∞, Œº¬∞H‚ÇÇO, Œ∫, v, p_bulk, pscale, nr, Œ≥, Œ≥H‚ÇÇO, kf, kb, nr‚Çõ, Œº¬∞‚Çõ, Œ≥‚Çõ, Œ≥‚ÇõH‚ÇÇO, k¬∞‚Çõ, ‚Ñ¨‚Çõ, Œ≤‚Çõ, k¬∞‚Çê, ‚Ñ¨‚Çê, Œ≤‚Çê, hbond_consts)
	end


	cell = PNPSystem(grid; bcondition = halfcellbc, reaction, celldata, unknown_storage=:dense)

	solver_control = (; max_round, maxiters, reltol, abstol, tol_round, tol_mono, damp_initial, damp_growth)

	result = ivsweep(cell; voltages, store_solutions=true, solver_control...)
	return result
end



begin # reaction
	const ùîûeducts_cache = DiffCache(zeros(5), 17)
	const ùîûproducts_cache = DiffCache(zeros(5), 17)
	const R_cache = DiffCache(zeros(5), 17)

	function reaction(f, u, node, data)
		(; iœï, ip, p_bulk, pscale, nc, v0, v, nr, Œ≥, Œ≥H‚ÇÇO, kf, kb, Œº¬∞, Œº¬∞H‚ÇÇO, RT) = data
		Tv = eltype(u)

		ùîûeducts = get_tmp(ùîûeducts_cache, u[iœï])
		ùîûproducts = get_tmp(ùîûproducts_cache, u[iœï])
		R = get_tmp(R_cache, u[iœï])

		ùîûeducts .= 1.0
		ùîûproducts .= 1.0
		R .= 0.0
		
		p = (u[ip]) * pscale - p_bulk
		@views c‚ÇÄ, cbar = c0_barc(u[1:nc], data)

		c = 1/(1-v[iK‚Å∫]*(u[iK‚Å∫]))
		for ic in 1:nc
			for ir in 1:nreactions(data)
				if Œ≥[ir, ic] < 0
					ùîûeducts[ir] *= (c * u[ic])^(-Œ≥[ir, ic])
				elseif Œ≥[ir, ic] > 0
					ùîûproducts[ir] *= (c * u[ic])^Œ≥[ir, ic]
				end
			end
		end

		for ir in 1:NReactions
		# if Œ≥H‚ÇÇO[ir] < 0
		# 	ùîûeducts[ir] *= (c‚ÇÄ)^(-Œ≥H‚ÇÇO[ir])
		# elseif Œ≥H‚ÇÇO[ir] > 0
		# 	ùîûproducts[ir] *= (c‚ÇÄ)^(Œ≥H‚ÇÇO[ir])
		# end
			R[ir] = kf[ir] * ùîûeducts[ir] - kb[ir] * ùîûproducts[ir]
		end

		for ic in 1:nc # production rates of the dissolved
			for ir in 1:nr
				f[ic] -= Œ≥[ir, ic] * R[ir]
			end
		end
		nothing
	end
end


begin # surface reaction
	const N‚Çõ_cache = DiffCache(zeros(7), 17)
	const R‚Çõ_cache = DiffCache(zeros(4), 17)
	const Œî·µ£Œº·∂ø‚Çõ_cache = DiffCache(zeros(4), 17)
	const ùîû‚Çõeducts_cache = DiffCache(ones(4), 17)
	const ùîû‚Çõproducts_cache = DiffCache(ones(4), 17)

	function we_breaction(f,
		u::VoronoiFVM.BNodeUnknowns{Tval, Tv, Tc, Tp, Ti}, 
		bnode,
		data::ElectrolyteData
	) where {Tval, Tv, Tc, Tp, Ti}
		(; iœï, ip, pscale, na, nc, nr‚Çõ, Œº¬∞, Œº¬∞‚Çõ, Œ≥‚Çõ, k¬∞‚Çõ, k¬∞‚Çê, Œ≥‚ÇõH‚ÇÇO, Œº¬∞H‚ÇÇO, ‚Ñ¨‚Çõ, ‚Ñ¨‚Çê, Œ≤‚Çõ, Œ≤‚Çê, œâ, z, hbond_consts, œï_we, RT, v0, v, p_bulk) = data

		N‚Çõ = get_tmp(N‚Çõ_cache, u[iœï]) # normal surface flux due to adsorption
		R‚Çõ = get_tmp(R‚Çõ_cache, u[iœï]) # surface reaction rates
		Œî·µ£Œº·∂ø‚Çõ = get_tmp(Œî·µ£Œº·∂ø‚Çõ_cache, u[iœï])
		ùîû‚Çõeducts = get_tmp(ùîû‚Çõeducts_cache, u[iœï])
		ùîû‚Çõproducts = get_tmp(ùîû‚Çõproducts_cache, u[iœï])

		N‚Çõ .= 0.0 # normal surface flux due to adsorption
		R‚Çõ .= 0.0 # surface reaction rates
		Œî·µ£Œº·∂ø‚Çõ .= 0.0
		ùîû‚Çõeducts .= 1.0
		ùîû‚Çõproducts .= 1.0

		@views c0, cbar = c0_barc(u[1:nc], data)
		@views cV‚Çõ, cbar‚Çõ = cV‚Çõ_barc‚Çõ(u[nc+1:nc+na], data)

		p = (u[ip]) * pscale - p_bulk
		œÉ = 0.0 #ForwardDiff.value(f[iœï]) #20.0 * ufac"ŒºA"/ufac"cm"^2
		
		for ia in 1:na
			(; a, b) = hbond_consts[ia]
			ŒîŒºœÉ = (a * œÉ + b * œÉ^2) * ph"e * N_A"
			ùîû‚Çõ = (ia == 2 | ia == 6) ? u[ia] / cbar : u[nc + ia] / cbar‚Çõ * (cbar‚Çõ / cV‚Çõ)^œâ[ia]
			for ir in 1:nr‚Çõ
				Œî·µ£Œº·∂ø‚Çõ[ir] += (ia == 2 | ia == 6) ? Œ≥‚Çõ[ir, ia] * (Œº¬∞[ia] + v[ia] * p) : Œ≥‚Çõ[ir, ia] * (Œº¬∞‚Çõ[ia] + ŒîŒºœÉ)
				if Œ≥‚Çõ[ir, ia] < 0
					ùîû‚Çõeducts[ir] *= ùîû‚Çõ^(-Œ≥‚Çõ[ir, ia])
				elseif Œ≥‚Çõ[ir, ia] > 0
					ùîû‚Çõproducts[ir] *= ùîû‚Çõ^Œ≥‚Çõ[ir, ia]
				end
			end
			
			if ia <= nc # adsorption rates
				ùîû‚Çõ = u[nc + ia] / cbar‚Çõ * (cbar‚Çõ / cV‚Çõ)^œâ[ia]
				ùîû = u[ia] / cbar
				Œî·µ£Œº·∂ø‚Çê = Œº¬∞‚Çõ[ia] + ŒîŒºœÉ - Œº¬∞[ia] - v[ia] * p
				Œ≤ = ismissing(Œ≤‚Çê[ia]) ? (Œî·µ£Œº·∂ø‚Çê > 0 ? 1.0 : 0.0) : Œ≤‚Çê[ia]
				N‚Çõ[ia] = k¬∞‚Çê[ia] * (exp(-1 / RT * (‚Ñ¨‚Çê[ia] + Œ≤ * Œî·µ£Œº·∂ø‚Çê)) * ùîû 
								-exp(-1 / RT * (‚Ñ¨‚Çê[ia] - (1-Œ≤) * Œî·µ£Œº·∂ø‚Çê)) * ùîû‚Çõ) 
			end
		end

		for ir in 1:nr‚Çõ
			Œî·µ£Œº·∂ø‚Çõ[ir] += Œ≥‚ÇõH‚ÇÇO[ir] * (Œº¬∞H‚ÇÇO + v0 * p)
			if Œ≥‚ÇõH‚ÇÇO[ir] > 0
				ùîû‚Çõproducts[ir] *= (c0/cbar)^Œ≥‚ÇõH‚ÇÇO[ir]
			elseif Œ≥‚ÇõH‚ÇÇO[ir] < 0
				ùîû‚Çõproducts[ir] *= (c0/cbar)^(-Œ≥‚ÇõH‚ÇÇO[ir])
			end
			Œ≤ = ismissing(Œ≤‚Çõ[ir]) ? (Œî·µ£Œº·∂ø‚Çõ[ir] > 0 ? 1.0 : 0.0) : Œ≤‚Çõ[ir]
			
			R‚Çõ[ir] = k¬∞‚Çõ[ir] * (
				exp(-1/RT * (‚Ñ¨‚Çõ[ir] + Œ≤ * Œî·µ£Œº·∂ø‚Çõ[ir])) * ùîû‚Çõeducts[ir]
			-exp(-1/RT * (‚Ñ¨‚Çõ[ir] - (1-Œ≤) * Œî·µ£Œº·∂ø‚Çõ[ir])) * ùîû‚Çõproducts[ir]
			)
		end

		R‚Çõ[2] *= c0/cbar
		
		for ia in 1:na # production rates of the surface species
			if (ia == 2 | ia == 6)
				for ir in 1:nr‚Çõ
					f[ia] -= Œ≥‚Çõ[ir, ia] * R‚Çõ[ir]
				end
			else
				for ir in 1:nr‚Çõ
					f[nc + ia] 	-= Œ≥‚Çõ[ir, ia] * R‚Çõ[ir]
				end
			end
			if ia <= nc
				f[nc + ia] 	-= N‚Çõ[ia]
				f[ia] 		-= -N‚Çõ[ia]
			end
		end
	end

end

function halfcellbc(
	f,
	u::VoronoiFVM.BNodeUnknowns{Tval, Tv, Tc, Tp, Ti}, 
	bnode,
	data
) where {Tval, Tv, Tc, Tp, Ti}
	(; Œì_we, Œì_bulk, œï_we, iœï) = data

	boundary_dirichlet!(f, u, bnode; species = iœï, region = Œì_we, value = œï_we)
	bulkbcondition(f, u, bnode, data; region = Œì_bulk)
	if bnode.region == Œì_we
		we_breaction(f, u, bnode, data)
	end
	nothing
end


begin ################### Utility Functions ###########################
	function cV‚Çõ_barc‚Çõ(c‚Çõ, data)
		(; œâ, œâM, aM) = data
		cV‚Çõ = œâM / aM - sum(œâ .* c‚Çõ)
		cÃÖ‚Çõ  = sum(c‚Çõ) + cV‚Çõ
		cV‚Çõ, cÃÖ‚Çõ
	end

	function surface_chemical_potential(c‚Çõ, cÃÖ‚Çõ, cV‚Çõ, œâ, data)
		(; RT) = data
		RT * rlog(c‚Çõ/cÃÖ‚Çõ, data) - œâ * RT * rlog(cV‚Çõ/cÃÖ‚Çõ, data)
	end

	function surfacefraction(ia, c‚Çõ, data)
		(; na, œâ, œâM, aM) = data
		cV‚Çõ = œâM / aM - sum(œâ .* c‚Çõ)
		cÃÖ‚Çõ  = sum(c‚Çõ) + cV‚Çõ
		ia == 0 ? cV‚Çõ / cÃÖ‚Çõ : c‚Çõ[ia] / cÃÖ‚Çõ
	end
end